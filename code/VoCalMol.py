"""
This file contains the necessary functions to calculate the inaccessible volume
of a molecule provided by a xyz-file
"""

import math
import numpy as np
import pandas as pd

# define dictionaries for atomic masses & radii
mass_dict = {"H": 1.0080,
             "C": 12.001,
             "N": 14.007,
             "O": 15.999,
             "S": 32.07,
             "P": 30.9737,
             "CA": 12.001,
             "K": 39.0983} # amu

radius_dict = {"H": 1.20,
               "C": 1.70,
               "N": 1.55,
               "O": 1.52,
               "S": 1.80,
               "P": 1.80,
               "CA": 1.7,
               "K": 2.75} # Ã…

# define a function to extract positions from file
def read_xyz(filepath):
    """
    function that reads a .xyz-file and extracts the x-,y- and z-coordinates as
    well as the element symbol and returns it as a pandas dataframe

    Parameters
    ----------
    filepath: str
        string that contains the name respectively location of the .pdb file

    Returns
    -------
    a pandas dataframe of the coordinates of the constituent molecules
    """

    xyz_data = []
    columns = ["Element", "X", "Y", "Z", "Atomic Mass", "Atomic Radius"]

    with open(filepath) as xyz:
        for line in xyz:
            xyz_data.append([line[3:6].strip(),
                             float(line[11:20]),
                             float(line[24:33]),
                             float(line[36:46])])
        #"""
        for i , row in enumerate(xyz_data):
            xyz_data[i].append(mass_dict[row[0]])
            xyz_data[i].append(radius_dict[row[0]])
        #"""

    return pd.DataFrame(xyz_data, columns=columns)

# define a function for coarse-graining large molecules
def coarse_graining(dataframe, grainsize=10):
    """
    a coarse graining function that summarizes particles into a single
    grain with weighted coordinates
    Parameters
    ----------
    grainsize: int
        number of particles being cumulated into a single grain
    dataframe: pandas dataframe
        dataframe gin the format generated by read_pdb

    Returns
    X_Grains: float array
        array containing the weighted x-coordinates of the grains
    Y_Grains: float array
        array containing the weighted y-coordinates of the grains
    Z_Grains: float array
        array containing the weighted z-coordinates of the grains
    -------

    """

    if grainsize == 1:  # no coarse-graining

        x_grains = dataframe["X"].values
        y_grains = dataframe["Y"].values
        z_grains = dataframe["Z"].values
        particle_radii = dataframe["Atomic Radius"].values

    else:

        N_Atoms = len(dataframe.index)
        modulo = N_Atoms % grainsize

        # print warning when last grain is significantly smaller
        if modulo / grainsize < 0.5:
            print("Attention: last grain is less than 50% in size compared to the others!")

        grain_start_id = np.arange(0, N_Atoms, grainsize)
        grain_end_id = np.append(grain_start_id[1:] - 1, N_Atoms - 1)

        x_grains = []
        y_grains = []
        z_grains = []
        particle_radii = []

        for start, end in zip(grain_start_id, grain_end_id):
            mass_vec = dataframe["Atomic Mass"][start:end]
            x_vec = dataframe["X"][start:end]
            y_vec = dataframe["Y"][start:end]
            z_vec = dataframe["Z"][start:end]
            max_x_dist = max(x_vec) - min(x_vec)
            max_y_dist = max(y_vec) - min(y_vec)
            max_z_dist = max(z_vec) - min(z_vec)
            max_dist = max([max_x_dist, max_y_dist, max_z_dist]) / 2  # max distance between

            weighted_x = ((mass_vec * x_vec).sum() / mass_vec.sum())
            weighted_y = ((mass_vec * y_vec).sum() / mass_vec.sum())
            weighted_z = ((mass_vec * z_vec).sum() / mass_vec.sum())

            x_grains.append(weighted_x)
            y_grains.append(weighted_y)
            z_grains.append(weighted_z)
            particle_radii.append(max_dist)

    x_grains = np.array(x_grains, dtype=float)
    y_grains = np.array(y_grains, dtype=float)
    z_grains = np.array(z_grains, dtype=float)
    particle_radii = np.array(particle_radii, dtype=float).reshape(-1, 1)

    return x_grains, y_grains, z_grains, particle_radii

# define function to initialize the positional array and the simulation box
def init_positions(mode, X, Y, Z, n_trials=100, n_walker=4, addboxlength=1):
    """
    function to set up the position array of the static, coarse grained molecule
    and the dynamic docking molecule. The provided coordinates of the static molecule
    further define the simulation box dimensions.
    Parameters
    ----------
    mode: str
        simulation mode since random walk requires start position outside of molecule
        as to not get stuck. Mode either "drop" or "walk"
    X: float array
        array containing the weighted x-coordinates of the grains
    Y: float array
        array containing the weighted y-coordinates of the grains
    Z: float array
        array containing the weighted z-coordinates of the grains
    n_trials: int
        number of simulation steps respectively trial moves
    addboxlength: int
        increase of side-lengths to create Simulation box

    Returns
    -------
    static_mol_pos: float array
        array containing the coordinates of the static molecule
    dynamic_mol_pos: float array
        presized array containing the initial coordinates of the dynamic docking particle
    boxdim: list of lists
        list of lists containing the lower and upper boundaries of the simulation box for
        periodic boundary conditions
    """
    boxdim = [[math.floor(min(X)) - addboxlength, math.ceil(max(X)) + addboxlength],
              [math.floor(min(Y)) - addboxlength, math.ceil(max(Y)) + addboxlength],
              [math.floor(min(Z)) - addboxlength, math.ceil(max(Z)) + addboxlength]]

    static_mol_pos = np.column_stack([X, Y, Z])

    if mode == "drop":
        dynamic_mol_pos = np.zeros((1, 3, n_trials))

        for i in range(3):
            dynamic_mol_pos[0, i, 0] = np.random.uniform(low=boxdim[i][0], high=boxdim[i][1])

    elif mode == "walk":
        dynamic_mol_pos = np.zeros((n_walker, 3, n_trials))

        for i in range(n_walker):
            rnd_dim = np.random.randint(3)

            if rnd_dim == 0:
                dynamic_mol_pos[i, :, 0] = [boxdim[0][0],
                                            np.random.uniform(boxdim[1][0], boxdim[1][1]),
                                            np.random.uniform(boxdim[2][0], boxdim[2][1])]
            if rnd_dim == 1:
                dynamic_mol_pos[i, :, 0] = [np.random.uniform(boxdim[0][0], boxdim[0][1]),
                                            boxdim[1][0],
                                            np.random.uniform(boxdim[2][0], boxdim[2][1])]
            else:
                dynamic_mol_pos[i, :, 0] = [np.random.uniform(boxdim[0][0], boxdim[0][1]),
                                            np.random.uniform(boxdim[1][0], boxdim[1][1]),
                                            boxdim[2][0]]

    else:
        raise ValueError("Simulation mode doesn't exist")

    return static_mol_pos, dynamic_mol_pos, boxdim

# define the function to calculate the distances between the dna-atoms and the dynamic particles
def calc_distances(static_positions, dynamic_positions):
    """
    function to calculate the distances between the static atoms and
    the dynamic particles
    Parameters
    ----------
    static_positions: float array
        array containing the coordinates of the static atoms
    dynamic_positions: float array
        array containing the coordinates of the dynamic atoms

    Returns
    -------
    r: float array
        array containing the pairwise distances between the static and
        dynamic atoms
    """

    dist = static_positions[:,np.newaxis,:] - dynamic_positions[np.newaxis,:,:]
    r = np.linalg.norm(dist,axis=2)

    return r

# define a function that governs the acceptance of the trial displacement
def move_acceptance(r, r_overlap=1, dyn_part_radius=0.):
    """
    function that returns a boolean: steps are rejected (FALSE) where the particle comes
    to close to one of the particles
    Parameters
    ----------
    r: float array
        array containing the respective distances between the static particles and
        the moving particle
    r_overlap: float array
        threshold distances i.e atomic radii to indicate overlap to guide acceptance rule

    Returns
    -------
    boolean
    """

    if np.sum(r < r_overlap + dyn_part_radius) > 0:
        return False
    else:
        return True

# define function to uniformly drop particles in the box
def trial_drop(boundaries):
    """
    function to generate a random new position of the particle within the simulation box
    Parameters
    ----------
    boundaries: list of lists
        upper and lower x-,y-,z-boundaries for the simulation box

    Returns
    -------
    new_pos
    """
    trial_position = np.zeros((1,3))

    for i in range(3):
        #trial_position.append(np.random.uniform(low=boundaries[i][0], high=boundaries[i][1]))
        trial_position[0][i] = np.random.uniform(low=boundaries[i][0], high=boundaries[i][1])

    return trial_position


# define function to perform random walk with periodic boundary condition
def trial_walk_pbc(old_position, boundaries, steplength=1.):
    """
    function to perform a trial displacement of the current docking particles position
    considering periodic boundary conditions
    Parameters
    ----------
    old_position: float array
        array containing the current position of the docking molecule
    steplength: float
        maximum displacement in each direction
    boundaries: list of lists
        list containing three lists with the lower and upper x-,y-, and z- coordinates

    Returns
    -------
    trial_position: float array
        aray containing the updated position of the docking molecule
    """

    trial_position = old_position + np.random.uniform(-steplength, steplength, (1, 3))

    if trial_position[0][0] < boundaries[0][0]:
        trial_position[0][0] = boundaries[0][1] - boundaries[0][0] % trial_position[0][0]
    if trial_position[0][0] > boundaries[0][1]:
        trial_position[0][0] = boundaries[0][0] + trial_position[0][0] % boundaries[0][1]
    if trial_position[0][1] < boundaries[1][0]:
        trial_position[0][1] = boundaries[1][1] - boundaries[1][0] % trial_position[0][1]
    if trial_position[0][1] > boundaries[1][1]:
        trial_position[0][1] = boundaries[1][0] + trial_position[0][1] % boundaries[1][1]
    if trial_position[0][2] < boundaries[2][0]:
        trial_position[0][2] = boundaries[2][1] - boundaries[2][0] % trial_position[0][2]
    if trial_position[0][2] > boundaries[2][1]:
        trial_position[0][2] = boundaries[2][0] + trial_position[0][2] % boundaries[2][1]

    return trial_position

# define function to run the drop simulation
def drop_simulation(static_mol_pos, dyn_mol_pos, boxdim, r_over, dyn_particle_radius=0.):
    """
    function that runs a complete simulation of the docking molecule with dropping mechanism

    Parameters
    ----------
    static_mol_pos: float array
        array containing the coordinates of the static molecule
    dyn_mol_pos: float array
        array containing the coordinates of the docking molecule
    boxdim: list of lists
        upper and lower x-,y-,z-boundaries for the simulation box
    dyn_particle_radius: float
        asumed radius of the dynamic particle

    Returns
    -------
    dyn_mol_pos: float array
        updated dynamic particle position array for all trials steps
    acceptance: boolean array
        array containing booleans for each timestep whether trial was accepted or not

    """
    acceptance = []
    r_0  = calc_distances(static_mol_pos,dyn_mol_pos[:,:,0])
    acceptance.append(move_acceptance(r=r_0, r_overlap=r_over, dyn_part_radius=dyn_particle_radius))

    for i in range(1,dyn_mol_pos.shape[2]):
        trial_pos = trial_drop(boundaries=boxdim)
        r_i = calc_distances(static_mol_pos, trial_pos)
        acceptance.append(move_acceptance(r=r_i, r_overlap=r_over,
                                          dyn_part_radius=dyn_particle_radius))

        if acceptance[i] == True:
            dyn_mol_pos[:,:,i] = trial_pos
        else:
            dyn_mol_pos[:,:, i] = dyn_mol_pos[:,:,i-1]

    return dyn_mol_pos, acceptance

# define function to run random walk simulation
def walk_simulation(static_mol_pos, dyn_mol_pos, boxdim, r_over, stepsize, dyn_particle_radius=0.):
    """
    function that runs a complete simulation of the docking molecule with walking mechanism

    Parameters
    ----------
    static_mol_pos: float array
        array containing the coordinates of the static molecule
    dyn_mol_pos: float array
        array containing the coordinates of the docking molecule

    Returns
    -------
    dyn_mol_pos: float array
        updated dynamic particle position array for all trials steps
    acceptance: boolean array
        array containing booleans for each timestep whether trial was accepted or not

    """
    acceptance = []
    n_walker = dyn_mol_pos.shape[0]
    r_0  = calc_distances(static_mol_pos,dyn_mol_pos[:,:,0])
    acceptance.append(move_acceptance(r=r_0, r_overlap=r_over, dyn_part_radius=dyn_particle_radius))

    for i in range(1,dyn_mol_pos.shape[2]):
        walker = np.random.randint(0,n_walker) # pick a walker
        trial_pos = trial_walk_pbc(old_position=dyn_mol_pos[walker, :, i-1],
                                   boundaries=boxdim, steplength=stepsize)
        r_i = calc_distances(static_mol_pos,trial_pos)
        acceptance.append(move_acceptance(r=r_i, r_overlap=r_over,
                                          dyn_part_radius=dyn_particle_radius))

        if acceptance[i] == True:
            dyn_mol_pos[:, :, i] = dyn_mol_pos[:, :, i-1]
            dyn_mol_pos[walker, :, i] = trial_pos
        else:
            dyn_mol_pos[:, :, i] = dyn_mol_pos[:, :, i-1]

    return dyn_mol_pos, acceptance

# define function to calculate volume of the static molecule including enclosed volume
def calc_molecule_volume(acceptance, boxdim):
    """
    function to calculate the volume of the static molecule

    Parameters
    ----------
    acceptance: boolean array
        array containing booleans for each timestep whether trial was accepted or not
    boxdim: list of lists
        upper and lower x-,y-,z-boundaries for the simulation box

    Returns
    -------
    V_mol_drop: float
        approximated volume of the molecule
    """
    V_box = np.prod([np.diff(b) for b in boxdim])
    acc_rate = sum(acceptance) / len(acceptance)
    V_mol = round(V_box * (1 - acc_rate),3)

    return V_mol

# define function to calculate static molecule volume without inaccessible volume
def calc_inaccessible_molecule_volume(dyn_walk_pos, boxdim, V_mol_drop, n_boxes=100):
    """
    function to calculate the inaccessible molecule volume. Basic mathematical premise:
    V_box = V_accessible + V_mol_real ;
    V_accessible = # of boxes visited by walk * volume of discrete box ;
    V_mol_inaccessible = V_mol_real - V_mol_drop ;

    Parameters
    ----------
    dyn_walk_pos: float array
        array containing the coordinates of the docking molecule
    boxdim: list of lists
        upper and lower x-,y-,z-boundaries for the simulation box
    V_mol_drop: float
        approximated volume from drop simulation consisting of real molecule volume and
        inaccessible molecule volume
    n_boxes: int
        number of boxes considered for volume approximation per side

    Returns
    -------
    V_mol_real: float
        real molecular volume
    V_mol_inaccessible: float
        inaccessible molecule volume
    """

    V_box = np.prod([np.diff(b) for b in boxdim])  # calculate volume of the simulation box

    dx = (boxdim[0][1] - boxdim[0][0]) / n_boxes
    dy = (boxdim[1][1] - boxdim[1][0]) / n_boxes
    dz = (boxdim[2][1] - boxdim[2][0]) / n_boxes
    discrete_box_volume = dx * dy * dz  # calculate volume of a single discrete box

    x_range = np.arange(boxdim[0][0], boxdim[0][1] + dx, dx)
    y_range = np.arange(boxdim[1][0], boxdim[1][1] + dy, dy)
    z_range = np.arange(boxdim[2][0], boxdim[2][1] + dz, dz)

    box_visits = np.zeros((n_boxes, n_boxes, n_boxes))

    for i in range(dyn_walk_pos.shape[2]):
        j = np.searchsorted(x_range, dyn_walk_pos[:, 0, i]) - 1
        j[j < 0] = 0

        k = np.searchsorted(y_range, dyn_walk_pos[:, 1, i]) - 1
        k[j < 0] = 0

        l = np.searchsorted(z_range, dyn_walk_pos[:, 2, i]) - 1
        l[j < 0] = 0

        box_visits[j, k, l] = 1

    n_cube_visits = box_visits.sum()
    V_accessible = n_cube_visits * discrete_box_volume
    V_mol_walk = V_box - V_accessible
    V_mol_inaccessible = V_mol_walk - V_mol_drop

    return V_mol_walk, V_mol_inaccessible
